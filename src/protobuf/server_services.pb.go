// Code generated by protoc-gen-go. DO NOT EDIT.
// source: server_services.proto

/*
Package serverservices is a generated protocol buffer package.

It is generated from these files:
	server_services.proto

It has these top-level messages:
	ConfigInfo
	StringMessage
	StringArray
	IntMessage
	DetectorMessage
	Member
	FullMembershipList
	UDPMessage
	FileCfg
	FileTransMessage
	PullFileInfo
*/
package serverservices

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ConfigInfo struct {
	LogLevel int32 `protobuf:"varint,1,opt,name=log_level,json=logLevel" json:"log_level,omitempty"`
	VmIndex  int32 `protobuf:"varint,2,opt,name=vm_index,json=vmIndex" json:"vm_index,omitempty"`
}

func (m *ConfigInfo) Reset()                    { *m = ConfigInfo{} }
func (m *ConfigInfo) String() string            { return proto.CompactTextString(m) }
func (*ConfigInfo) ProtoMessage()               {}
func (*ConfigInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ConfigInfo) GetLogLevel() int32 {
	if m != nil {
		return m.LogLevel
	}
	return 0
}

func (m *ConfigInfo) GetVmIndex() int32 {
	if m != nil {
		return m.VmIndex
	}
	return 0
}

type StringMessage struct {
	Mesg string `protobuf:"bytes,1,opt,name=mesg" json:"mesg,omitempty"`
}

func (m *StringMessage) Reset()                    { *m = StringMessage{} }
func (m *StringMessage) String() string            { return proto.CompactTextString(m) }
func (*StringMessage) ProtoMessage()               {}
func (*StringMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StringMessage) GetMesg() string {
	if m != nil {
		return m.Mesg
	}
	return ""
}

type StringArray struct {
	Mesgs []string `protobuf:"bytes,1,rep,name=mesgs" json:"mesgs,omitempty"`
}

func (m *StringArray) Reset()                    { *m = StringArray{} }
func (m *StringArray) String() string            { return proto.CompactTextString(m) }
func (*StringArray) ProtoMessage()               {}
func (*StringArray) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *StringArray) GetMesgs() []string {
	if m != nil {
		return m.Mesgs
	}
	return nil
}

type IntMessage struct {
	Mesg int32 `protobuf:"varint,1,opt,name=mesg" json:"mesg,omitempty"`
}

func (m *IntMessage) Reset()                    { *m = IntMessage{} }
func (m *IntMessage) String() string            { return proto.CompactTextString(m) }
func (*IntMessage) ProtoMessage()               {}
func (*IntMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *IntMessage) GetMesg() int32 {
	if m != nil {
		return m.Mesg
	}
	return 0
}

type DetectorMessage struct {
	Header  string `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Addr    string `protobuf:"bytes,2,opt,name=addr" json:"addr,omitempty"`
	SessNum int32  `protobuf:"varint,3,opt,name=sess_num,json=sessNum" json:"sess_num,omitempty"`
	Ttl     int32  `protobuf:"varint,4,opt,name=ttl" json:"ttl,omitempty"`
	NodeId  int32  `protobuf:"varint,5,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
}

func (m *DetectorMessage) Reset()                    { *m = DetectorMessage{} }
func (m *DetectorMessage) String() string            { return proto.CompactTextString(m) }
func (*DetectorMessage) ProtoMessage()               {}
func (*DetectorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DetectorMessage) GetHeader() string {
	if m != nil {
		return m.Header
	}
	return ""
}

func (m *DetectorMessage) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *DetectorMessage) GetSessNum() int32 {
	if m != nil {
		return m.SessNum
	}
	return 0
}

func (m *DetectorMessage) GetTtl() int32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *DetectorMessage) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

type Member struct {
	Addr    string `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	SessNum int32  `protobuf:"varint,2,opt,name=sess_num,json=sessNum" json:"sess_num,omitempty"`
	NodeId  int32  `protobuf:"varint,3,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
}

func (m *Member) Reset()                    { *m = Member{} }
func (m *Member) String() string            { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()               {}
func (*Member) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Member) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Member) GetSessNum() int32 {
	if m != nil {
		return m.SessNum
	}
	return 0
}

func (m *Member) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

type FullMembershipList struct {
	List []*Member `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *FullMembershipList) Reset()                    { *m = FullMembershipList{} }
func (m *FullMembershipList) String() string            { return proto.CompactTextString(m) }
func (*FullMembershipList) ProtoMessage()               {}
func (*FullMembershipList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FullMembershipList) GetList() []*Member {
	if m != nil {
		return m.List
	}
	return nil
}

type UDPMessage struct {
	MessageType string              `protobuf:"bytes,1,opt,name=message_type,json=messageType" json:"message_type,omitempty"`
	Dm          *DetectorMessage    `protobuf:"bytes,2,opt,name=dm" json:"dm,omitempty"`
	Fm          *FullMembershipList `protobuf:"bytes,3,opt,name=fm" json:"fm,omitempty"`
}

func (m *UDPMessage) Reset()                    { *m = UDPMessage{} }
func (m *UDPMessage) String() string            { return proto.CompactTextString(m) }
func (*UDPMessage) ProtoMessage()               {}
func (*UDPMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UDPMessage) GetMessageType() string {
	if m != nil {
		return m.MessageType
	}
	return ""
}

func (m *UDPMessage) GetDm() *DetectorMessage {
	if m != nil {
		return m.Dm
	}
	return nil
}

func (m *UDPMessage) GetFm() *FullMembershipList {
	if m != nil {
		return m.Fm
	}
	return nil
}

// SDFS related messages
type FileCfg struct {
	RemoteFilepath string `protobuf:"bytes,1,opt,name=remote_filepath,json=remoteFilepath" json:"remote_filepath,omitempty"`
	RepNumber      int32  `protobuf:"varint,2,opt,name=rep_number,json=repNumber" json:"rep_number,omitempty"`
}

func (m *FileCfg) Reset()                    { *m = FileCfg{} }
func (m *FileCfg) String() string            { return proto.CompactTextString(m) }
func (*FileCfg) ProtoMessage()               {}
func (*FileCfg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *FileCfg) GetRemoteFilepath() string {
	if m != nil {
		return m.RemoteFilepath
	}
	return ""
}

func (m *FileCfg) GetRepNumber() int32 {
	if m != nil {
		return m.RepNumber
	}
	return 0
}

type FileTransMessage struct {
	// Types that are valid to be assigned to Message:
	//	*FileTransMessage_Chunk
	//	*FileTransMessage_Config
	Message isFileTransMessage_Message `protobuf_oneof:"message"`
}

func (m *FileTransMessage) Reset()                    { *m = FileTransMessage{} }
func (m *FileTransMessage) String() string            { return proto.CompactTextString(m) }
func (*FileTransMessage) ProtoMessage()               {}
func (*FileTransMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isFileTransMessage_Message interface {
	isFileTransMessage_Message()
}

type FileTransMessage_Chunk struct {
	Chunk []byte `protobuf:"bytes,1,opt,name=chunk,proto3,oneof"`
}
type FileTransMessage_Config struct {
	Config *FileCfg `protobuf:"bytes,2,opt,name=config,oneof"`
}

func (*FileTransMessage_Chunk) isFileTransMessage_Message()  {}
func (*FileTransMessage_Config) isFileTransMessage_Message() {}

func (m *FileTransMessage) GetMessage() isFileTransMessage_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *FileTransMessage) GetChunk() []byte {
	if x, ok := m.GetMessage().(*FileTransMessage_Chunk); ok {
		return x.Chunk
	}
	return nil
}

func (m *FileTransMessage) GetConfig() *FileCfg {
	if x, ok := m.GetMessage().(*FileTransMessage_Config); ok {
		return x.Config
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FileTransMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FileTransMessage_OneofMarshaler, _FileTransMessage_OneofUnmarshaler, _FileTransMessage_OneofSizer, []interface{}{
		(*FileTransMessage_Chunk)(nil),
		(*FileTransMessage_Config)(nil),
	}
}

func _FileTransMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FileTransMessage)
	// message
	switch x := m.Message.(type) {
	case *FileTransMessage_Chunk:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Chunk)
	case *FileTransMessage_Config:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Config); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FileTransMessage.Message has unexpected type %T", x)
	}
	return nil
}

func _FileTransMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FileTransMessage)
	switch tag {
	case 1: // message.chunk
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Message = &FileTransMessage_Chunk{x}
		return true, err
	case 2: // message.config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileCfg)
		err := b.DecodeMessage(msg)
		m.Message = &FileTransMessage_Config{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FileTransMessage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FileTransMessage)
	// message
	switch x := m.Message.(type) {
	case *FileTransMessage_Chunk:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Chunk)))
		n += len(x.Chunk)
	case *FileTransMessage_Config:
		s := proto.Size(x.Config)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// For pull file
type PullFileInfo struct {
	FileName  string `protobuf:"bytes,1,opt,name=file_name,json=fileName" json:"file_name,omitempty"`
	NumOfFile int32  `protobuf:"varint,2,opt,name=num_of_file,json=numOfFile" json:"num_of_file,omitempty"`
	MyID      int32  `protobuf:"varint,3,opt,name=myID" json:"myID,omitempty"`
}

func (m *PullFileInfo) Reset()                    { *m = PullFileInfo{} }
func (m *PullFileInfo) String() string            { return proto.CompactTextString(m) }
func (*PullFileInfo) ProtoMessage()               {}
func (*PullFileInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *PullFileInfo) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *PullFileInfo) GetNumOfFile() int32 {
	if m != nil {
		return m.NumOfFile
	}
	return 0
}

func (m *PullFileInfo) GetMyID() int32 {
	if m != nil {
		return m.MyID
	}
	return 0
}

func init() {
	proto.RegisterType((*ConfigInfo)(nil), "serverservices.ConfigInfo")
	proto.RegisterType((*StringMessage)(nil), "serverservices.StringMessage")
	proto.RegisterType((*StringArray)(nil), "serverservices.StringArray")
	proto.RegisterType((*IntMessage)(nil), "serverservices.IntMessage")
	proto.RegisterType((*DetectorMessage)(nil), "serverservices.DetectorMessage")
	proto.RegisterType((*Member)(nil), "serverservices.Member")
	proto.RegisterType((*FullMembershipList)(nil), "serverservices.FullMembershipList")
	proto.RegisterType((*UDPMessage)(nil), "serverservices.UDPMessage")
	proto.RegisterType((*FileCfg)(nil), "serverservices.FileCfg")
	proto.RegisterType((*FileTransMessage)(nil), "serverservices.FileTransMessage")
	proto.RegisterType((*PullFileInfo)(nil), "serverservices.PullFileInfo")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ServerServices service

type ServerServicesClient interface {
	ServerConfig(ctx context.Context, in *ConfigInfo, opts ...grpc.CallOption) (*StringMessage, error)
	ReturnMatches(ctx context.Context, in *StringArray, opts ...grpc.CallOption) (ServerServices_ReturnMatchesClient, error)
	CloseServer(ctx context.Context, in *IntMessage, opts ...grpc.CallOption) (*StringMessage, error)
	ActMembership(ctx context.Context, in *StringArray, opts ...grpc.CallOption) (*StringMessage, error)
	// SDFS client stub
	SdfsCall(ctx context.Context, in *StringArray, opts ...grpc.CallOption) (*StringArray, error)
	// SDFS related functions
	TransferFiles(ctx context.Context, opts ...grpc.CallOption) (ServerServices_TransferFilesClient, error)
	PullFiles(ctx context.Context, in *PullFileInfo, opts ...grpc.CallOption) (*IntMessage, error)
	PutFile(ctx context.Context, in *StringMessage, opts ...grpc.CallOption) (*IntMessage, error)
}

type serverServicesClient struct {
	cc *grpc.ClientConn
}

func NewServerServicesClient(cc *grpc.ClientConn) ServerServicesClient {
	return &serverServicesClient{cc}
}

func (c *serverServicesClient) ServerConfig(ctx context.Context, in *ConfigInfo, opts ...grpc.CallOption) (*StringMessage, error) {
	out := new(StringMessage)
	err := grpc.Invoke(ctx, "/serverservices.ServerServices/ServerConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServicesClient) ReturnMatches(ctx context.Context, in *StringArray, opts ...grpc.CallOption) (ServerServices_ReturnMatchesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ServerServices_serviceDesc.Streams[0], c.cc, "/serverservices.ServerServices/ReturnMatches", opts...)
	if err != nil {
		return nil, err
	}
	x := &serverServicesReturnMatchesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ServerServices_ReturnMatchesClient interface {
	Recv() (*StringMessage, error)
	grpc.ClientStream
}

type serverServicesReturnMatchesClient struct {
	grpc.ClientStream
}

func (x *serverServicesReturnMatchesClient) Recv() (*StringMessage, error) {
	m := new(StringMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *serverServicesClient) CloseServer(ctx context.Context, in *IntMessage, opts ...grpc.CallOption) (*StringMessage, error) {
	out := new(StringMessage)
	err := grpc.Invoke(ctx, "/serverservices.ServerServices/CloseServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServicesClient) ActMembership(ctx context.Context, in *StringArray, opts ...grpc.CallOption) (*StringMessage, error) {
	out := new(StringMessage)
	err := grpc.Invoke(ctx, "/serverservices.ServerServices/ActMembership", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServicesClient) SdfsCall(ctx context.Context, in *StringArray, opts ...grpc.CallOption) (*StringArray, error) {
	out := new(StringArray)
	err := grpc.Invoke(ctx, "/serverservices.ServerServices/SdfsCall", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServicesClient) TransferFiles(ctx context.Context, opts ...grpc.CallOption) (ServerServices_TransferFilesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ServerServices_serviceDesc.Streams[1], c.cc, "/serverservices.ServerServices/TransferFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &serverServicesTransferFilesClient{stream}
	return x, nil
}

type ServerServices_TransferFilesClient interface {
	Send(*FileTransMessage) error
	CloseAndRecv() (*IntMessage, error)
	grpc.ClientStream
}

type serverServicesTransferFilesClient struct {
	grpc.ClientStream
}

func (x *serverServicesTransferFilesClient) Send(m *FileTransMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *serverServicesTransferFilesClient) CloseAndRecv() (*IntMessage, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(IntMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *serverServicesClient) PullFiles(ctx context.Context, in *PullFileInfo, opts ...grpc.CallOption) (*IntMessage, error) {
	out := new(IntMessage)
	err := grpc.Invoke(ctx, "/serverservices.ServerServices/PullFiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServicesClient) PutFile(ctx context.Context, in *StringMessage, opts ...grpc.CallOption) (*IntMessage, error) {
	out := new(IntMessage)
	err := grpc.Invoke(ctx, "/serverservices.ServerServices/PutFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ServerServices service

type ServerServicesServer interface {
	ServerConfig(context.Context, *ConfigInfo) (*StringMessage, error)
	ReturnMatches(*StringArray, ServerServices_ReturnMatchesServer) error
	CloseServer(context.Context, *IntMessage) (*StringMessage, error)
	ActMembership(context.Context, *StringArray) (*StringMessage, error)
	// SDFS client stub
	SdfsCall(context.Context, *StringArray) (*StringArray, error)
	// SDFS related functions
	TransferFiles(ServerServices_TransferFilesServer) error
	PullFiles(context.Context, *PullFileInfo) (*IntMessage, error)
	PutFile(context.Context, *StringMessage) (*IntMessage, error)
}

func RegisterServerServicesServer(s *grpc.Server, srv ServerServicesServer) {
	s.RegisterService(&_ServerServices_serviceDesc, srv)
}

func _ServerServices_ServerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServicesServer).ServerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serverservices.ServerServices/ServerConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServicesServer).ServerConfig(ctx, req.(*ConfigInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerServices_ReturnMatches_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StringArray)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ServerServicesServer).ReturnMatches(m, &serverServicesReturnMatchesServer{stream})
}

type ServerServices_ReturnMatchesServer interface {
	Send(*StringMessage) error
	grpc.ServerStream
}

type serverServicesReturnMatchesServer struct {
	grpc.ServerStream
}

func (x *serverServicesReturnMatchesServer) Send(m *StringMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _ServerServices_CloseServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServicesServer).CloseServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serverservices.ServerServices/CloseServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServicesServer).CloseServer(ctx, req.(*IntMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerServices_ActMembership_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringArray)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServicesServer).ActMembership(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serverservices.ServerServices/ActMembership",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServicesServer).ActMembership(ctx, req.(*StringArray))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerServices_SdfsCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringArray)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServicesServer).SdfsCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serverservices.ServerServices/SdfsCall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServicesServer).SdfsCall(ctx, req.(*StringArray))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerServices_TransferFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ServerServicesServer).TransferFiles(&serverServicesTransferFilesServer{stream})
}

type ServerServices_TransferFilesServer interface {
	SendAndClose(*IntMessage) error
	Recv() (*FileTransMessage, error)
	grpc.ServerStream
}

type serverServicesTransferFilesServer struct {
	grpc.ServerStream
}

func (x *serverServicesTransferFilesServer) SendAndClose(m *IntMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *serverServicesTransferFilesServer) Recv() (*FileTransMessage, error) {
	m := new(FileTransMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ServerServices_PullFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullFileInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServicesServer).PullFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serverservices.ServerServices/PullFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServicesServer).PullFiles(ctx, req.(*PullFileInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerServices_PutFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServicesServer).PutFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serverservices.ServerServices/PutFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServicesServer).PutFile(ctx, req.(*StringMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServerServices_serviceDesc = grpc.ServiceDesc{
	ServiceName: "serverservices.ServerServices",
	HandlerType: (*ServerServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ServerConfig",
			Handler:    _ServerServices_ServerConfig_Handler,
		},
		{
			MethodName: "CloseServer",
			Handler:    _ServerServices_CloseServer_Handler,
		},
		{
			MethodName: "ActMembership",
			Handler:    _ServerServices_ActMembership_Handler,
		},
		{
			MethodName: "SdfsCall",
			Handler:    _ServerServices_SdfsCall_Handler,
		},
		{
			MethodName: "PullFiles",
			Handler:    _ServerServices_PullFiles_Handler,
		},
		{
			MethodName: "PutFile",
			Handler:    _ServerServices_PutFile_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReturnMatches",
			Handler:       _ServerServices_ReturnMatches_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TransferFiles",
			Handler:       _ServerServices_TransferFiles_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "server_services.proto",
}

func init() { proto.RegisterFile("server_services.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 674 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0x4d, 0x73, 0xda, 0x3a,
	0x14, 0xc5, 0x7c, 0x73, 0x81, 0x24, 0xa3, 0x79, 0x2f, 0xe1, 0x25, 0x2f, 0xef, 0x51, 0x67, 0xd1,
	0x4c, 0x17, 0x69, 0x4b, 0xff, 0x40, 0x53, 0x18, 0x1a, 0xda, 0x90, 0x10, 0x93, 0xae, 0x3d, 0x0e,
	0xbe, 0x06, 0x4f, 0x25, 0x9b, 0x91, 0x64, 0xa6, 0xac, 0xfb, 0x17, 0xfa, 0x57, 0xbb, 0xef, 0x48,
	0xb2, 0x87, 0x8f, 0xa4, 0x64, 0xd1, 0x15, 0xba, 0xc7, 0x57, 0x47, 0x47, 0x47, 0xe7, 0x0e, 0xf0,
	0xb7, 0x40, 0xbe, 0x40, 0xee, 0xaa, 0x9f, 0x70, 0x82, 0xe2, 0x62, 0xce, 0x63, 0x19, 0x93, 0x3d,
	0x03, 0x67, 0xa8, 0xdd, 0x03, 0xe8, 0xc6, 0x51, 0x10, 0x4e, 0x07, 0x51, 0x10, 0x93, 0x13, 0xa8,
	0xd1, 0x78, 0xea, 0x52, 0x5c, 0x20, 0x6d, 0x59, 0x6d, 0xeb, 0xbc, 0xe4, 0x54, 0x69, 0x3c, 0xbd,
	0x56, 0x35, 0xf9, 0x07, 0xaa, 0x0b, 0xe6, 0x86, 0x91, 0x8f, 0xdf, 0x5a, 0x79, 0xfd, 0xad, 0xb2,
	0x60, 0x03, 0x55, 0xda, 0x67, 0xd0, 0x1c, 0x4b, 0x1e, 0x46, 0xd3, 0x21, 0x0a, 0xe1, 0x4d, 0x91,
	0x10, 0x28, 0x32, 0x14, 0x53, 0xcd, 0x51, 0x73, 0xf4, 0xda, 0x3e, 0x83, 0xba, 0x69, 0xba, 0xe4,
	0xdc, 0x5b, 0x92, 0xbf, 0xa0, 0xa4, 0x60, 0xd1, 0xb2, 0xda, 0x85, 0xf3, 0x9a, 0x63, 0x0a, 0xbb,
	0x0d, 0x30, 0x88, 0xe4, 0x53, 0x34, 0xa5, 0x94, 0xe6, 0xbb, 0x05, 0xfb, 0x3d, 0x94, 0x38, 0x91,
	0x31, 0xcf, 0xfa, 0x0e, 0xa1, 0x3c, 0x43, 0xcf, 0x47, 0x9e, 0x1e, 0x98, 0x56, 0x6a, 0xbf, 0xe7,
	0xfb, 0x5c, 0xcb, 0xad, 0x39, 0x7a, 0xad, 0xae, 0x21, 0x50, 0x08, 0x37, 0x4a, 0x58, 0xab, 0x60,
	0xae, 0xa1, 0xea, 0x9b, 0x84, 0x91, 0x03, 0x28, 0x48, 0x49, 0x5b, 0x45, 0x8d, 0xaa, 0x25, 0x39,
	0x82, 0x4a, 0x14, 0xfb, 0xe8, 0x86, 0x7e, 0xab, 0xa4, 0xd1, 0xb2, 0x2a, 0x07, 0xbe, 0x3d, 0x82,
	0xf2, 0x10, 0xd9, 0xc3, 0xda, 0x19, 0xd6, 0x6f, 0xce, 0xc8, 0x6f, 0x9e, 0xb1, 0xc6, 0x58, 0xd8,
	0x60, 0x7c, 0x0f, 0xa4, 0x9f, 0x50, 0x6a, 0x58, 0xc5, 0x2c, 0x9c, 0x5f, 0x87, 0x42, 0x92, 0x57,
	0x50, 0xa4, 0xa1, 0x90, 0xda, 0xa4, 0x7a, 0xe7, 0xf0, 0x62, 0xf3, 0xf9, 0x2e, 0x4c, 0xb7, 0xa3,
	0x7b, 0xec, 0x1f, 0x16, 0xc0, 0x97, 0xde, 0x28, 0x33, 0xe5, 0x05, 0x34, 0x98, 0x59, 0xba, 0x72,
	0x39, 0xc7, 0x54, 0x60, 0x3d, 0xc5, 0xee, 0x97, 0x73, 0x24, 0xaf, 0x21, 0xef, 0x1b, 0x85, 0xf5,
	0xce, 0xff, 0xdb, 0xdc, 0x5b, 0x26, 0x3b, 0x79, 0x9f, 0x91, 0x0e, 0xe4, 0x03, 0x63, 0x5b, 0xbd,
	0x63, 0x6f, 0x6f, 0x78, 0x2c, 0xdf, 0xc9, 0x07, 0xcc, 0xbe, 0x83, 0x4a, 0x3f, 0xa4, 0xd8, 0x0d,
	0xa6, 0xe4, 0x25, 0xec, 0x73, 0x64, 0xb1, 0x44, 0x37, 0x08, 0x29, 0xce, 0x3d, 0x39, 0x4b, 0x55,
	0xed, 0x19, 0xb8, 0x9f, 0xa2, 0xe4, 0x14, 0x80, 0xe3, 0x5c, 0xf9, 0xf7, 0x80, 0x3c, 0xb5, 0xb0,
	0xc6, 0x71, 0x7e, 0xa3, 0x01, 0x7b, 0x06, 0x07, 0xaa, 0xf5, 0x9e, 0x7b, 0x91, 0x58, 0x65, 0xa0,
	0x34, 0x99, 0x25, 0xd1, 0x57, 0xcd, 0xd8, 0xb8, 0xca, 0x39, 0xa6, 0x24, 0x6f, 0xa1, 0x3c, 0xd1,
	0x09, 0x4f, 0xef, 0x79, 0xf4, 0x48, 0xb6, 0x11, 0x77, 0x95, 0x73, 0xd2, 0xc6, 0x0f, 0x35, 0xa8,
	0xa4, 0x2e, 0xd9, 0x2e, 0x34, 0x46, 0x09, 0xa5, 0xaa, 0x27, 0x9b, 0x10, 0x25, 0xdd, 0x8d, 0x3c,
	0x96, 0x39, 0x5a, 0x55, 0xc0, 0x8d, 0xc7, 0x90, 0xfc, 0x07, 0xf5, 0x28, 0x61, 0x6e, 0x1c, 0xe8,
	0xeb, 0x65, 0xb2, 0xa3, 0x84, 0xdd, 0x06, 0x8a, 0x40, 0xc7, 0x79, 0x39, 0xe8, 0xa5, 0x0f, 0xaf,
	0xd7, 0x9d, 0x9f, 0x45, 0xd8, 0x1b, 0x6b, 0x41, 0xe3, 0x54, 0x10, 0xf9, 0x0c, 0x0d, 0x83, 0x98,
	0xc9, 0x24, 0xc7, 0xdb, 0x8a, 0x57, 0x13, 0x7b, 0x7c, 0xba, 0xfd, 0x6d, 0x63, 0x0e, 0xed, 0x1c,
	0xb9, 0x85, 0xa6, 0x83, 0x32, 0xe1, 0xd1, 0xd0, 0x93, 0x93, 0x19, 0x0a, 0x72, 0xf2, 0xf4, 0x0e,
	0x3d, 0x94, 0xcf, 0xd2, 0xbd, 0xb1, 0xc8, 0x27, 0xa8, 0x77, 0x69, 0x2c, 0xd0, 0x48, 0x7c, 0x2c,
	0x6e, 0x35, 0xbe, 0xcf, 0x8b, 0x1b, 0x42, 0xf3, 0x72, 0x22, 0x57, 0x99, 0xf9, 0x33, 0x71, 0xa4,
	0x0f, 0xd5, 0xb1, 0x1f, 0x88, 0xae, 0x47, 0xe9, 0x6e, 0xa6, 0x5d, 0x1f, 0xed, 0x1c, 0xb9, 0x83,
	0xa6, 0x8e, 0x56, 0x80, 0x5c, 0xbd, 0x9b, 0x20, 0xed, 0xa7, 0x32, 0xb3, 0x9e, 0xbe, 0xe3, 0x1d,
	0x36, 0xd8, 0xb9, 0x73, 0x8b, 0x7c, 0x84, 0x5a, 0x96, 0x23, 0x41, 0xfe, 0xdd, 0x6e, 0x5e, 0x8f,
	0xd8, 0x6e, 0x2a, 0xd2, 0x87, 0xca, 0x28, 0x91, 0x3a, 0x4e, 0xbb, 0xfd, 0xd8, 0xcd, 0xf3, 0x50,
	0xd6, 0xff, 0x07, 0xef, 0x7e, 0x05, 0x00, 0x00, 0xff, 0xff, 0x70, 0x4e, 0xd2, 0x2b, 0x28, 0x06,
	0x00, 0x00,
}
