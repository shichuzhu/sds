// Code generated by protoc-gen-go. DO NOT EDIT.
// source: server_services.proto

/*
Package serverservices is a generated protocol buffer package.

It is generated from these files:
	server_services.proto

It has these top-level messages:
	ConfigInfo
	GrepLine
	Cmd
	CloseMessage
	Info
	DetectorMessage
	Member
	FullMembershipList
	UDPMessage
*/
package serverservices

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ConfigInfo struct {
	LogLevel int32 `protobuf:"varint,1,opt,name=log_level,json=logLevel" json:"log_level,omitempty"`
	VMIndex  int32 `protobuf:"varint,2,opt,name=VMIndex,json=vMIndex" json:"VMIndex,omitempty"`
}

func (m *ConfigInfo) Reset()                    { *m = ConfigInfo{} }
func (m *ConfigInfo) String() string            { return proto.CompactTextString(m) }
func (*ConfigInfo) ProtoMessage()               {}
func (*ConfigInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ConfigInfo) GetLogLevel() int32 {
	if m != nil {
		return m.LogLevel
	}
	return 0
}

func (m *ConfigInfo) GetVMIndex() int32 {
	if m != nil {
		return m.VMIndex
	}
	return 0
}

type GrepLine struct {
	Line string `protobuf:"bytes,1,opt,name=line" json:"line,omitempty"`
}

func (m *GrepLine) Reset()                    { *m = GrepLine{} }
func (m *GrepLine) String() string            { return proto.CompactTextString(m) }
func (*GrepLine) ProtoMessage()               {}
func (*GrepLine) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GrepLine) GetLine() string {
	if m != nil {
		return m.Line
	}
	return ""
}

type Cmd struct {
	Cmd string `protobuf:"bytes,1,opt,name=cmd" json:"cmd,omitempty"`
}

func (m *Cmd) Reset()                    { *m = Cmd{} }
func (m *Cmd) String() string            { return proto.CompactTextString(m) }
func (*Cmd) ProtoMessage()               {}
func (*Cmd) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Cmd) GetCmd() string {
	if m != nil {
		return m.Cmd
	}
	return ""
}

type CloseMessage struct {
	CloseType int32 `protobuf:"varint,1,opt,name=closeType" json:"closeType,omitempty"`
}

func (m *CloseMessage) Reset()                    { *m = CloseMessage{} }
func (m *CloseMessage) String() string            { return proto.CompactTextString(m) }
func (*CloseMessage) ProtoMessage()               {}
func (*CloseMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CloseMessage) GetCloseType() int32 {
	if m != nil {
		return m.CloseType
	}
	return 0
}

type Info struct {
	Info string `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
}

func (m *Info) Reset()                    { *m = Info{} }
func (m *Info) String() string            { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()               {}
func (*Info) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Info) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

type DetectorMessage struct {
	Header  string `protobuf:"bytes,1,opt,name=Header,json=header" json:"Header,omitempty"`
	Addr    string `protobuf:"bytes,2,opt,name=Addr,json=addr" json:"Addr,omitempty"`
	SessNUm int32  `protobuf:"varint,3,opt,name=SessNUm,json=sessNUm" json:"SessNUm,omitempty"`
	TTL     int32  `protobuf:"varint,4,opt,name=TTL,json=tTL" json:"TTL,omitempty"`
}

func (m *DetectorMessage) Reset()                    { *m = DetectorMessage{} }
func (m *DetectorMessage) String() string            { return proto.CompactTextString(m) }
func (*DetectorMessage) ProtoMessage()               {}
func (*DetectorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DetectorMessage) GetHeader() string {
	if m != nil {
		return m.Header
	}
	return ""
}

func (m *DetectorMessage) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *DetectorMessage) GetSessNUm() int32 {
	if m != nil {
		return m.SessNUm
	}
	return 0
}

func (m *DetectorMessage) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

type Member struct {
	Addr    string `protobuf:"bytes,1,opt,name=Addr,json=addr" json:"Addr,omitempty"`
	SessNum int32  `protobuf:"varint,2,opt,name=SessNum,json=sessNum" json:"SessNum,omitempty"`
}

func (m *Member) Reset()                    { *m = Member{} }
func (m *Member) String() string            { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()               {}
func (*Member) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Member) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Member) GetSessNum() int32 {
	if m != nil {
		return m.SessNum
	}
	return 0
}

type FullMembershipList struct {
	List []*Member `protobuf:"bytes,1,rep,name=List,json=list" json:"List,omitempty"`
}

func (m *FullMembershipList) Reset()                    { *m = FullMembershipList{} }
func (m *FullMembershipList) String() string            { return proto.CompactTextString(m) }
func (*FullMembershipList) ProtoMessage()               {}
func (*FullMembershipList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *FullMembershipList) GetList() []*Member {
	if m != nil {
		return m.List
	}
	return nil
}

type UDPMessage struct {
	MessageType string              `protobuf:"bytes,1,opt,name=MessageType,json=messageType" json:"MessageType,omitempty"`
	Dm          *DetectorMessage    `protobuf:"bytes,2,opt,name=Dm,json=dm" json:"Dm,omitempty"`
	Fm          *FullMembershipList `protobuf:"bytes,3,opt,name=Fm,json=fm" json:"Fm,omitempty"`
}

func (m *UDPMessage) Reset()                    { *m = UDPMessage{} }
func (m *UDPMessage) String() string            { return proto.CompactTextString(m) }
func (*UDPMessage) ProtoMessage()               {}
func (*UDPMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *UDPMessage) GetMessageType() string {
	if m != nil {
		return m.MessageType
	}
	return ""
}

func (m *UDPMessage) GetDm() *DetectorMessage {
	if m != nil {
		return m.Dm
	}
	return nil
}

func (m *UDPMessage) GetFm() *FullMembershipList {
	if m != nil {
		return m.Fm
	}
	return nil
}

func init() {
	proto.RegisterType((*ConfigInfo)(nil), "serverservices.ConfigInfo")
	proto.RegisterType((*GrepLine)(nil), "serverservices.GrepLine")
	proto.RegisterType((*Cmd)(nil), "serverservices.Cmd")
	proto.RegisterType((*CloseMessage)(nil), "serverservices.CloseMessage")
	proto.RegisterType((*Info)(nil), "serverservices.Info")
	proto.RegisterType((*DetectorMessage)(nil), "serverservices.DetectorMessage")
	proto.RegisterType((*Member)(nil), "serverservices.Member")
	proto.RegisterType((*FullMembershipList)(nil), "serverservices.FullMembershipList")
	proto.RegisterType((*UDPMessage)(nil), "serverservices.UDPMessage")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ServerServices service

type ServerServicesClient interface {
	ServerConfig(ctx context.Context, in *ConfigInfo, opts ...grpc.CallOption) (*Info, error)
	ReturnMatches(ctx context.Context, in *Cmd, opts ...grpc.CallOption) (ServerServices_ReturnMatchesClient, error)
	CloseServer(ctx context.Context, in *CloseMessage, opts ...grpc.CallOption) (*Info, error)
}

type serverServicesClient struct {
	cc *grpc.ClientConn
}

func NewServerServicesClient(cc *grpc.ClientConn) ServerServicesClient {
	return &serverServicesClient{cc}
}

func (c *serverServicesClient) ServerConfig(ctx context.Context, in *ConfigInfo, opts ...grpc.CallOption) (*Info, error) {
	out := new(Info)
	err := grpc.Invoke(ctx, "/serverservices.ServerServices/ServerConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServicesClient) ReturnMatches(ctx context.Context, in *Cmd, opts ...grpc.CallOption) (ServerServices_ReturnMatchesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ServerServices_serviceDesc.Streams[0], c.cc, "/serverservices.ServerServices/ReturnMatches", opts...)
	if err != nil {
		return nil, err
	}
	x := &serverServicesReturnMatchesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ServerServices_ReturnMatchesClient interface {
	Recv() (*GrepLine, error)
	grpc.ClientStream
}

type serverServicesReturnMatchesClient struct {
	grpc.ClientStream
}

func (x *serverServicesReturnMatchesClient) Recv() (*GrepLine, error) {
	m := new(GrepLine)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *serverServicesClient) CloseServer(ctx context.Context, in *CloseMessage, opts ...grpc.CallOption) (*Info, error) {
	out := new(Info)
	err := grpc.Invoke(ctx, "/serverservices.ServerServices/CloseServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ServerServices service

type ServerServicesServer interface {
	ServerConfig(context.Context, *ConfigInfo) (*Info, error)
	ReturnMatches(*Cmd, ServerServices_ReturnMatchesServer) error
	CloseServer(context.Context, *CloseMessage) (*Info, error)
}

func RegisterServerServicesServer(s *grpc.Server, srv ServerServicesServer) {
	s.RegisterService(&_ServerServices_serviceDesc, srv)
}

func _ServerServices_ServerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServicesServer).ServerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serverservices.ServerServices/ServerConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServicesServer).ServerConfig(ctx, req.(*ConfigInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerServices_ReturnMatches_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Cmd)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ServerServicesServer).ReturnMatches(m, &serverServicesReturnMatchesServer{stream})
}

type ServerServices_ReturnMatchesServer interface {
	Send(*GrepLine) error
	grpc.ServerStream
}

type serverServicesReturnMatchesServer struct {
	grpc.ServerStream
}

func (x *serverServicesReturnMatchesServer) Send(m *GrepLine) error {
	return x.ServerStream.SendMsg(m)
}

func _ServerServices_CloseServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServicesServer).CloseServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serverservices.ServerServices/CloseServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServicesServer).CloseServer(ctx, req.(*CloseMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServerServices_serviceDesc = grpc.ServiceDesc{
	ServiceName: "serverservices.ServerServices",
	HandlerType: (*ServerServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ServerConfig",
			Handler:    _ServerServices_ServerConfig_Handler,
		},
		{
			MethodName: "CloseServer",
			Handler:    _ServerServices_CloseServer_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReturnMatches",
			Handler:       _ServerServices_ReturnMatches_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "server_services.proto",
}

func init() { proto.RegisterFile("server_services.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 453 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x53, 0x51, 0x6f, 0xd3, 0x30,
	0x10, 0x5e, 0x9a, 0xd0, 0x2d, 0x97, 0x31, 0xd0, 0x01, 0x23, 0x2a, 0x13, 0x54, 0x7e, 0x9a, 0x10,
	0x2a, 0x28, 0x48, 0x3c, 0xc3, 0x52, 0x0d, 0x26, 0xa5, 0x08, 0xa5, 0x1d, 0xaf, 0x53, 0x17, 0x5f,
	0xdb, 0x48, 0x49, 0x5c, 0xd9, 0x69, 0x05, 0xbf, 0x83, 0xdf, 0xc7, 0x7f, 0x41, 0xb6, 0x13, 0x3a,
	0x52, 0xf6, 0xe4, 0xfb, 0x3e, 0xdf, 0x7d, 0xfe, 0xee, 0x72, 0x81, 0x67, 0x8a, 0xe4, 0x96, 0xe4,
	0x8d, 0x3e, 0xf2, 0x8c, 0xd4, 0x68, 0x2d, 0x45, 0x2d, 0xf0, 0xc4, 0xd2, 0x2d, 0xcb, 0x62, 0x80,
	0x58, 0x54, 0x8b, 0x7c, 0x79, 0x55, 0x2d, 0x04, 0xbe, 0x00, 0xbf, 0x10, 0xcb, 0x9b, 0x82, 0xb6,
	0x54, 0x84, 0xce, 0xd0, 0x39, 0x7f, 0x90, 0x1e, 0x15, 0x62, 0x99, 0x68, 0x8c, 0x21, 0x1c, 0x7e,
	0x9f, 0x5c, 0x55, 0x9c, 0x7e, 0x84, 0x3d, 0x73, 0x75, 0xb8, 0xb5, 0x90, 0xbd, 0x84, 0xa3, 0xcf,
	0x92, 0xd6, 0x49, 0x5e, 0x11, 0x22, 0x78, 0x45, 0x5e, 0x91, 0xa9, 0xf6, 0x53, 0x13, 0xb3, 0xe7,
	0xe0, 0xc6, 0x25, 0xc7, 0xc7, 0xe0, 0x66, 0x25, 0x6f, 0x6e, 0x74, 0xc8, 0xde, 0xc0, 0x71, 0x5c,
	0x08, 0x45, 0x13, 0x52, 0x6a, 0xbe, 0x24, 0x3c, 0x03, 0x3f, 0xd3, 0x78, 0xf6, 0x73, 0x4d, 0xcd,
	0xfb, 0x3b, 0x82, 0x0d, 0xc0, 0x33, 0x2e, 0x11, 0xbc, 0xbc, 0x5a, 0x88, 0xf6, 0x09, 0x1d, 0xb3,
	0x1c, 0x1e, 0x8d, 0xa9, 0xa6, 0xac, 0x16, 0xb2, 0x15, 0x3b, 0x85, 0xfe, 0x17, 0x9a, 0x73, 0x92,
	0x4d, 0x62, 0x7f, 0x65, 0x90, 0x2e, 0xff, 0xc4, 0xb9, 0x34, 0x4d, 0xf8, 0xa9, 0x37, 0xe7, 0x5c,
	0xea, 0xde, 0xa6, 0xa4, 0xd4, 0xd7, 0xeb, 0x32, 0x74, 0x6d, 0x6f, 0xca, 0x42, 0x6d, 0x7a, 0x36,
	0x4b, 0x42, 0xcf, 0xb0, 0x6e, 0x3d, 0x4b, 0xd8, 0x07, 0xe8, 0x4f, 0xa8, 0xbc, 0xbd, 0xa3, 0xe4,
	0xfc, 0x47, 0x69, 0x53, 0xb6, 0x53, 0x52, 0x16, 0xb2, 0x8f, 0x80, 0x97, 0x9b, 0xa2, 0xb0, 0xb5,
	0x6a, 0x95, 0xaf, 0x93, 0x5c, 0xd5, 0xf8, 0x1a, 0x3c, 0x7d, 0x86, 0xce, 0xd0, 0x3d, 0x0f, 0xa2,
	0xd3, 0xd1, 0xbf, 0xdf, 0x67, 0x64, 0xb3, 0xf5, 0x1c, 0x55, 0xcd, 0x7e, 0x39, 0x00, 0xd7, 0xe3,
	0x6f, 0x6d, 0x83, 0x43, 0x08, 0x9a, 0xf0, 0xef, 0xbc, 0xfc, 0x34, 0x28, 0x77, 0x14, 0xbe, 0x85,
	0xde, 0xd8, 0xfa, 0x08, 0xa2, 0x57, 0x5d, 0xe9, 0xce, 0xbc, 0xd2, 0x1e, 0x2f, 0x31, 0x82, 0xde,
	0xa5, 0x1d, 0x41, 0x10, 0xb1, 0x6e, 0xc1, 0xbe, 0xfb, 0xb4, 0xb7, 0x28, 0xa3, 0xdf, 0x0e, 0x9c,
	0x4c, 0x4d, 0xe6, 0xb4, 0xc9, 0xc4, 0x0b, 0x38, 0xb6, 0x8c, 0xdd, 0x2d, 0x1c, 0x74, 0xa5, 0x76,
	0x3b, 0x37, 0x78, 0xda, 0xbd, 0xd3, 0x2c, 0x3b, 0xc0, 0x0b, 0x78, 0x98, 0x52, 0xbd, 0x91, 0xd5,
	0x64, 0x5e, 0x67, 0x2b, 0x52, 0xf8, 0x64, 0x4f, 0xa4, 0xe4, 0x83, 0xb0, 0x4b, 0xb6, 0x8b, 0xc8,
	0x0e, 0xde, 0x39, 0x18, 0x43, 0x60, 0xf6, 0xcb, 0x9a, 0xc1, 0xb3, 0x3d, 0x85, 0x3b, 0xcb, 0x77,
	0x9f, 0x91, 0xdb, 0xbe, 0xf9, 0x73, 0xde, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x20, 0x16, 0x1d,
	0xf0, 0x52, 0x03, 0x00, 0x00,
}
